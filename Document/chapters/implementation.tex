%% TODO: Add a small paragraph to tell what this chapter is about
This chapter delves into the implementation of each module inside Test Genie system. Overall, this system consist of three main modules: 
\begin{itemize}
    \item[-] \textbf{Project Manager}: This module manages all the projects that are cloned to server. It mostly responsible for file-based activities and running CLI for each project.
    \item[-] \textbf{Business Logic Analyzer}: This module will take various source file from Project Manager and break the source code into smaller pieces (blocks). Then, it will analyze each block and determine what each block does and how it should be tested if possible. A test plan will also be generated for each block and save it to the database.
    \item[-] \textbf{Test Generator}: This module will take the test plan from Business Logic Analyzer and generate a test case for each block. The generated test cases will be saved as files directly in the project source code on server and can be used to run the tests later (validation).
\end{itemize}
Additionally, this system also have \textbf{DBMS} module to control the database but this module will not be explained thoroughly in this chapter.

%% TODO: Make sure to use \textbf or \textit for highlighting keywords, and \cite{} to cite the corresponding quotations

\section{Project Manager module}

The \textbf{ProjectManager} module serves as the core backend functionality for handling projects within the Test Genie system. It provides a robust framework for managing software projects by integrating Git-based repositories, file management, and testing workflows. The module is built around the \textit{Project} class, which encapsulates essential functionalities such as cloning repositories, recognizing project frameworks, and managing project files. Additionally, it features an abstract interface for test creation, validation, and execution, allowing for framework-specific extensions of functionality. For instance, the \textit{Flutter} subclass extends the \textit{Project} class to handle Flutter-specific tasks, including dependency management, `pubspec.yaml` parsing, and test execution. By modularizing these functionalities, the \textbf{ProjectManager} module streamlines project handling and enhances the system's scalability for various software development frameworks.

\subsection{Module prequisites}
This module require the SDK of supported frameworks to be installed standablone in folder \textit{./SDKs} inside the module folder. This design not only allows the module to be easily extended and modifiled to support other frameworks, but also avoid more SDK installation on the server OS. Since the \textit{Project} class (Listing A.1) just mainly control git management and file management, the subclass can freely control how the SDKs are used. \\

Subclass of Project are required to implement the following methods:
    \begin{itemize}
        \item[-] \textbf{create\_test}: This method will create the test file in the location that is required by the framework.
        \item[-] \textbf{get\_test\_content}: This method will return the content of the test file that is created by the \textbf{create\_test} method. The content of the test file is generated by the Business Logic Analyzer module.
        \item[-] \textbf{run\_test}: This method will run the test file that is created by the \textbf{create\_test} method. The test result will be returned to the caller.
        \item[-] \textbf{validate}: This method will run all the test files in the test directory and return the result. This method is used to validate the test files that are created by the \textbf{create\_test} method.
        \item[-] \textbf{getListSourceFiles}: This is an important method, which will partly decide how the source code is split into blocks. The starting point file (main file) should be placed on the first position of the list. The list will be used to split the source code into blocks. The list should contain all the source files in the project (relative to the project directory).
    \end{itemize}


\subsection{Flutter class}

The \textbf{Flutter} class extends the \textbf{Project} class to provide framework-specific support for managing Flutter projects. This class is responsible for handling operations unique to Flutter, such as managing dependencies, running tests, and validating projects. It ensures that the Flutter SDK is installed and properly configured in the \textit{./SDKs/flutter} directory before performing any operations.

Key methods of the \textbf{Flutter} class include:
\begin{itemize}
    \item[-] \textbf{\_runFlutterCLI}: This method executes commands using the Flutter CLI within the context of the project directory. It supports arguments for various Flutter commands and handles errors if the command fails.
    \item[-] \textbf{\_checkSDK}: Ensures that the Flutter SDK is installed and operational by running the \texttt{flutter --version} command. If the SDK is not present or misconfigured, the method raises an exception.
    \item[-] \textbf{\_flutterPubGet}: Automatically installs dependencies listed in the \textit{pubspec.yaml} file by running \texttt{flutter pub get}.
    \item[-] \textbf{\_addTestDependency}: Adds the Flutter \textit{test} package as a dependency using \texttt{flutter pub add test}.
    \item[-] \textbf{create\_test}: Creates a test file in the designated \textit{test} directory of the project. If the file already exists and overwriting is not allowed, an exception is raised.
    \item[-] \textbf{get\_test\_content}: Retrieves the content of a test file from the \textit{test} directory.
    \item[-] \textbf{run\_test}: Executes a specified Dart test file using the Flutter CLI and returns the results.
    \item[-] \textbf{validate}: Iterates through all Dart test files in the \textit{test} directory and validates them by running each test.
    \item[-] \textbf{getListSourceFiles}: Collects and returns a list of all source files in the \textit{lib} directory, ensuring that the \textit{main.dart} file is prioritized as the entry point.
\end{itemize}

This design enables seamless integration of Flutter-specific features into the \textbf{Test Genie} system while adhering to the modular structure defined by the \textbf{Project} class. By implementing these methods, the \textbf{Flutter} class ensures compatibility with the broader system and provides developers with a streamlined process for managing and testing Flutter projects.

\section{Business Logic Analyzer module}

The \textbf{Business Logic Analyzer} module is designed to parse and analyze the source code of a project. It constructs a \textbf{Dependency Diagram} that represents the logical structure and relationships within the project. By leveraging framework-specific analysis strategies, such as the \textit{FlutterAnalyzeStrategy}, this module identifies functional blocks and their interconnections. Each block is further enriched with predictions generated by the \textbf{AI Agent}, which analyzes the code to provide insights into its behavior and logic. This modular design allows the Business Logic Analyzer to be easily extended to support additional frameworks, making it versatile and scalable for various software projects. The output of this module serves as the foundation for the subsequent test generation process.

\subsection{DependencyDiagram class}

The \textbf{DependencyDiagram} class serves as a connector within the Test Genie system, bridging the gap between the framework-specific analysis strategies, such as \textit{FlutterAnalyzeStrategy}, and the AI-powered prediction functionality provided by the \textbf{AI\_Agent}. This class is responsible for constructing a logical representation of the project in the form of a dependency diagram, which comprises blocks (representing functional units) and connections (representing the relationships between those units). The \textbf{\_generateDiagram} method encapsulates this functionality by invoking the appropriate analysis strategy for the project's framework (Listing A.3), allowing the class to dynamically adapt to diverse frameworks supported by the system. This modular design ensures that the class is both extensible and maintainable as new frameworks are introduced.

In addition to structural analysis, the \textbf{DependencyDiagram} class leverages the \textbf{AI\_Agent} to enrich the diagram with meaningful predictions. Through the \textbf{\_getPre-dictions} method (Listing A.3), each block in the diagram is analyzed to generate insights into its behavior and logic, which are subsequently embedded into the block. This integration of AI-based predictions and static code analysis makes the \textbf{DependencyDiagram} a powerful tool for understanding the project's overall architecture and behavior. By combining these two mechanisms, this class plays a pivotal role in preparing the business logic analyzation for further steps in the Test Genie system: test generation and validation.

\subsubsection{Diagram objects}


The DependencyDiagram class relies on objects from the Diagram folder to represent the blocks and connections within the dependency structure. These objects are defined as follows:

\begin{itemize}
    \item[-] \textbf{Block class}: Represents the functional units of the source code, such as files, classes, functions, or variables (Listing A.4). Each block contains the following attributes:
    \begin{itemize}
        \item[-] \textit{name}: The name of the block.
        \item[-] \textit{content}: The source code or content of the block.
        \item[-] \textit{type}: The type of the block, determined by the BlockType class.
        \item[-] \textit{prediction}: (Optional) AI-generated predictions for the block's logic or behavior.
    \end{itemize}
    Additionally, the Block class provides methods such as:
    \begin{itemize}
        \item[-] \textbf{getContentNoComment}: Removes comments from the block's content for clean analysis.
        \item[-] \textbf{setPrediction} and \textbf{getPrediction}: Manage predictions for the block.
    \end{itemize}

    \item[-] \textbf{BlockType class}: Enumerates the possible types of blocks (Listing A.5), such as \textit{File}, \textit{Class}, \textit{Function}, and more. It also provides methods to:
    \begin{itemize}
        \item[-] Generate database queries for storing and managing block types.
        \item[-] Define the schema for the BlockType database table.
    \end{itemize}

    \item[-] \textbf{Connection class}: Represents relationships between blocks (Listing A.6), with attributes:
    \begin{itemize}
        \item[-] \textit{head}: The source block of the connection.
        \item[-] \textit{tail}: The destination block of the connection.
        \item[-] \textit{type}: The type of relationship, determined by the ConnectionType class.
    \end{itemize}
    It also facilitates database storage and retrieval through schema definitions.

    \item[-] \textbf{ConnectionType class}: Enumerates the types of relationships between blocks (Listing A.7), such as \textit{Extend}, \textit{Implement}, \textit{Call}, and \textit{Import}. It provides similar database-related methods as the BlockType class.
\end{itemize}

\subsubsection{FlutterAnalyzeStrategy Algorithm}

The \textbf{FlutterAnalyzeStrategy} function (Listing A.8) is a core component of the \textbf{DependencyDiagram} generation process within the \textbf{Business Logic Analyzer} module. This function is specifically designed to analyze Flutter projects by reading their source code, breaking it into logical units (\textit{blocks}), and appending these blocks to the diagram. It employs three custom backtracking algorithms (\textit{ImportAnalyzer}, \textit{ContainAnalyzer}, and \textit{CallAnalyzer}) to achieve a comprehensive structural and relational analysis of the project. Here's a detailed breakdown of the algorithm:

\begin{itemize}
    \item[-] \textbf{Initialization:}
    \begin{itemize}
        \item The function begins by retrieving the list of source files in the project using the \textbf{getListSourceFiles} method from the \textbf{Project} class (Listing A.1).
        \item The first file in the list is assumed to be the project's entry point (typically \texttt{main.dart}). Its content is extracted, and a new \textbf{Block} object is created to represent it. This block is assigned the \texttt{FILE} type from the \textbf{BlockType} class.
        \item The newly created \texttt{main.dart} block is appended to the \textbf{blocks} attribute of the \textbf{DependencyDiagram} instance.
    \end{itemize}

    \item[-] \textbf{Import Analysis (ImportAnalyzer):}
    \begin{itemize}
        \item The \textbf{ImportAnalyzer} algorithm (Listing A.9) scans the content of the \texttt{main.dart} block for \texttt{import} statements. These statements indicate dependencies on other Dart libraries or files.
        \item For each \texttt{import} statement, a \textbf{Connection} object is created between the current block (as the \textit{head}) and the imported file (as the \textit{tail}). The connection type is marked as \texttt{IMPORT}.
        \item Unlike the other analyzers, \textbf{ImportAnalyzer} primarily focuses on establishing file-level relationships and does not create new blocks.
    \end{itemize}

    \item[-] \textbf{Containment Analysis (ContainAnalyzer):}
    \begin{itemize}
        \item The \textbf{ContainAnalyzer} algorithm (Listing A.10) dives deeper into each file to identify hierarchical relationships within the code. For example:
        \begin{itemize}
            \item Classes contained within files.
            \item Standalone functions contained within files.
            \item Functions and attributes contained within classes.
        \end{itemize}
        \item For each identified entity, a new \textbf{Block} object is created and appended to the \textbf{blocks} list. The type of the block is determined based on the entity, such as \texttt{CLASS}, \texttt{FUNCTION}, or \texttt{CLASS\_ATTRIBUTE}.
        \item Connections are established between the parent block (e.g., the file block) and the contained entities, using the \texttt{CONTAIN} relationship type.
    \end{itemize}

    \item[-] \textbf{Call Analysis (CallAnalyzer):}
    \begin{itemize}
        \item The \textbf{CallAnalyzer} algorithm (Listing A.11) identifies calling activities between functions and classes. For instance:
        \begin{itemize}
            \item Functions calling other functions, either within the same file or across files.
            \item Methods from one class invoking methods or attributes of another class.
        \end{itemize}
        \item For each calling activity found, a \textbf{Connection} object is created to represent the caller (as the \textit{head}) and the callee (as the \textit{tail}). The relationship type for these connections is set to \texttt{CALL}.
        \item This analysis also considers cross-file and cross-class interactions, providing insights into the dynamic flow of the project.
    \end{itemize}

    \item[-] \textbf{Finalizing the Diagram:}
    \begin{itemize}
        \item After executing the three algorithms, the \textbf{blocks} list of the \textbf{DependencyDiagram} instance contains a comprehensive representation of the project's structural elements.
        \item Similarly, the \textbf{connections} list captures the relationships between these elements, making the diagram a complete and versatile model of the project's dependencies and interactions.
    \end{itemize}
\end{itemize}

The \textbf{FlutterAnalyzeStrategy} function effectively combines the results of these three backtracking algorithms to deliver a detailed and accurate dependency diagram. By modularizing the analysis into distinct phases (\textit{Import Analysis}, \textit{Containment Analysis}, and \textit{Call Analysis}), the function ensures that the structural and relational aspects of the project are thoroughly captured. This makes it an indispensable part of the Test Genie system's ability to analyze and generate tests for Flutter projects.

\subsection{AI\_Agent class}

The \textbf{AI\_Agent} class is a component of the Test Genie system that provide AI-driven insights into the business logic of analyzed code blocks using \textit{Langchain framework} ~\cite{langchain}. This class is initialized within the \textbf{DependencyDiagram} class and utilized in the \textit{\_getPredictions} method (Listing A.3) to generate structured predictions for each block. The initialization process of the \textbf{AI\_Agent} involves setting up its environment, loading necessary resources, and preparing the underlying AI models and vector stores.

\subsubsection{Initialization Flow}

The initialization of the \textbf{AI\_Agent} class (Listing A.12) involves several key steps to prepare its environment and components:

\begin{itemize}
    \item[-] \textbf{Environment Setup:}
    \begin{itemize}
        \item The class begins by loading environment variables from a \texttt{.env} file using the \texttt{load\_dotenv} function. If the file fails to load, an exception is raised.
        \item Critical environment variables (Listing A.13) include:
        \begin{itemize}
            \item \texttt{BASE\_URL}: The base URL for API requests.
            \item \texttt{BLA\_LLM\_MODEL}: The name of the language model used for predictions.
            \item \texttt{EMBED\_MODEL}: The embedding model used for vectorization.
        \end{itemize}
    \end{itemize}

    \item[-] \textbf{Model and Embedding Initialization:}
    \begin{itemize}
        \item A \textbf{ChatOpenAI} instance is initialized for interacting with the language model. This instance is configured with the \texttt{BASE\_URL} and \texttt{BLA\_LLM\_MODEL}.
        \item An \textbf{OpenAIEmbeddings} instance is initialized for generating document embeddings. It is configured to skip context length checks for compatibility with specific setups.
    \end{itemize}

    \item[-] \textbf{Vector Store Creation:}
    \begin{itemize}
        \item The \textbf{AI\_Agent} manages document vector stores for efficient retrieval. A predefined list of documents (e.g., \texttt{flutter\_tutorial.pdf}) is used to populate these stores.
        \item For each document:
        \begin{itemize}
            \item The document is loaded using appropriate loaders (e.g., \textbf{PyPDFLoader}).
            \item The document is split into chunks using the \textbf{SentenceTransformersTokenTextSplitter}.
            \item A persistent vector store is created for the document using the \textbf{Chroma} library.
        \end{itemize}
        \item If a vector store already exists for a document, it is reused without reinitialization.
    \end{itemize}

    \item[-] \textbf{Retriever Initialization:}
    \begin{itemize}
        \item For each vector store, a \textbf{retriever} is configured to fetch relevant documents based on similarity thresholds. These retrievers are stored for later use.
    \end{itemize}

    \item[-] \textbf{Agent Initialization:}
    \begin{itemize}
        \item The \textit{\_agent\_init} method is invoked to set up a history-aware retrieval system and define the agent's behavior for analyzing code.
        \item Custom prompts are created for contextualizing queries and for generating predictions. These prompts guide the language model in providing detailed business logic analysis and testing scenarios.
        \item A \textbf{react\_agent} is created using the \textbf{create\_react\_agent} function, and its execution is managed by an \textbf{AgentExecutor}.
    \end{itemize}
\end{itemize}

\subsubsection{generate\_BLA\_prediction Function}

The \textbf{generate\_BLA\_prediction} function (Listing A.12) is the primary method of the \textbf{AI\_Agent} class, responsible for analyzing source code and generating structured predictions. It takes two input parameters: \texttt{source\_code}, which is the code snippet to be analyzed, and \texttt{chat\_history}, a list of previous interactions that provide context for the analysis. These inputs allow the function to understand the context of the code and any prior discussions related to it.

The function begins by invoking the \textbf{agent\_executor}, which analyzes the source code in the context of the provided chat history. The executor uses the retrievers and the language model to perform an initial analysis, retrieving any relevant documents from the vector stores to assist in understanding the code. This step produces a preliminary output that captures the essential details of the code's functionality and properties.

Once the initial analysis is complete, the function refines the output by directly querying the language model with a structured prompt. This prompt is specifically designed to guide the model in organizing the analysis into well-defined sections. These sections include a brief explanation of what the code does, an assessment of its testability, and a set of detailed testing scenarios. The testing scenarios are formatted to clearly describe the functionality being tested, the input values, and the expected outcomes. This ensures that the generated test cases are practical, comprehensive, and easy to understand.

The final structured response produced by the language model includes three main components. The first is a \textbf{Brief Explanation}, summarizing the purpose and functionality of the code. The second is a \textbf{Testability Assessment}, evaluating whether the code can be tested and identifying the appropriate types of tests, such as unit, widget, or integration tests. The third component is a list of \textbf{Testing Scenarios}, which outlines specific test cases with descriptive names, input values, and expected behaviors. These scenarios ensure coverage of normal cases, edge cases, and special conditions, providing a thorough basis for test planning.

The structured response generated by the \textit{generate\_BLA\_prediction} function serves as the final output, ready to be integrated into the \textbf{DependencyDiagram} for further use. By combining retrieval-augmented generation with precise prompts, this function delivers high-quality insights that enable efficient and accurate test planning for Flutter/Dart projects.

\section{Test Generator module}

\section{Other implementations}

\section{Implemetation Result - Demo}