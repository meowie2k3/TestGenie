\begin{lstlisting}[language=Python, caption={$\texttt{Project}$ class.}, label={lst:1}]
  import os
  import subprocess
  
  class Project:

      _framework = ''
      def __init__(self, git_url):
          self._git_url = git_url
          self._name = git_url.split('/')[-1]
          # print('Project name: ', self._name)
          if self._name.endswith('.git'):
              self._name = self._name[:-4]
          
          # check if project already cloned
          if os.path.exists(projectDir + '/' + self._name):
              return
          else:
              self._clone(git_url)
      
      def _clone(self, git_url):
          # clone the git repository to the project directory
          try:
              # if Project folder not exist, create it
              if not os.path.exists(projectDir):
                  os.makedirs(projectDir)
              return subprocess.check_output(['git', 'clone', git_url, projectDir + '/' + self._name], universal_newlines=True)
          except subprocess.CalledProcessError as e:
              raise Exception(f'Error cloning project: {e}')
      
      def recognizeProjectFramework(self) -> str:
          # TODO: Implement project framework recognition
          return 'flutter'
          pass
      
      def _setFramework(self, framework) -> None:
          self._framework = framework
          
      def getFramework(self) -> str:
          return self._framework
      
      def getName(self) -> str:
          return self._name
      
      def getPath(self) -> str:
          return projectDir + '/' + self._name
          
      def getFileContent(self, fileDir: str) -> str:
          """_summary_
  
          Args:
              fileDir (str): file directory relative to project directory
  
          Returns:
              str: file content
          """
          with open(os.path.join(projectDir, self.getName(), fileDir), 'r') as f:
              return f.read()
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{Flutter}$ class - subclass of Project.}, label={lst:2}]
from ProjectManager import Project, projectDir, os, subprocess, sdkDir

sdkDir = os.path.join(sdkDir, 'flutter')

class Flutter(Project): # Inherit from Project class
    
    def __init__(self, git_url):
        super().__init__(git_url)
        self._setFramework('Flutter')
        self._checkSDK()
        self._flutterPubGet()
        self._addTestDependency()
        self.yaml_name = self._getYamlName()
        # self._createSampleProject('sample')
        
    def _runFlutterCLI(self, args, isRaiseException=False) -> tuple:
        prjDir = os.path.join(projectDir, self.getName())
        flutterBatDir = os.path.join(sdkDir, 'bin', 'flutter')

        cmd = [flutterBatDir]
        # args handling
        # if args is a string that have space, convert it to list
        if isinstance(args, str) and ' ' in args:
            args = args.split()
        if isinstance(args, list):
            cmd.extend(args)
            
        # run cmd via subprocess
        try:
            process = subprocess.Popen(cmd, cwd=prjDir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, encoding='utf-8', shell=True)
            stdout, stderr = process.communicate()
            if process.returncode != 0 and isRaiseException:
                raise Exception(f'Error running flutter command: {stderr}')
            return stdout, stderr
        except subprocess.CalledProcessError as e:
            if isRaiseException:
                raise Exception(f'Error running flutter command: {e}')
            return e.__dict__, e.args
    
    def _checkSDK(self) -> None:
        # Check if flutter sdk is installed
        if not os.path.exists(sdkDir):
            print('Flutter SDK not found')
            return
        # run sdk from sdkDir
        try:
            self._runFlutterCLI('--version', isRaiseException=True)
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error checking flutter sdk: {e}')
        
        # print(result)
    
    def _getYamlName(self) -> str:

        yamlContent = self.getFileContent('pubspec.yaml')
        # print(yamlContent)
        # first line should define the name of the project: "name: ....."
        return yamlContent.split('\n')[0].split('name: ')[1].strip()

    
    # function for testing only. Do not use in production
    def _createSampleProject(self, prjName) -> str:
        try:
            # cannot use _runFlutterCLI because no project directory yet
            # result = self._runFlutterCLI(['create', prjName], isRaiseException=True)
            result = subprocess.check_output([os.path.join(sdkDir, 'bin', 'flutter'), 'create', prjName],cwd=projectDir, universal_newlines=True, encoding='utf-8',  shell=True)
            
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error creating flutter project: {e}')
        return result
    
    def _flutterPubGet(self) -> None:
        # prjDir = os.path.join(projectDir, self.getName())
        # flutterBatDir = os.path.join(sdkDir, 'bin', 'flutter.bat')
        
        try:
            # result = subprocess.check_output([flutterBatDir, 'pub', 'get'], cwd=prjDir, universal_newlines=True)
            self._runFlutterCLI(['pub', 'get', '--no-example'], isRaiseException=True)
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error running flutter pub get: {e}')
        
        # print(result)
        
    def _addTestDependency(self) -> None:
        # run pub add test
        try:
            self._runFlutterCLI(['pub', 'add', 'test'], isRaiseException=True)
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error adding test dependency: {e}')
        # print(result)
    
    def create_test(self, filename, content, isOverWrite = False) -> None:
        # create test file in the test directory
        # check if test directory exists
        testDir = os.path.join(projectDir, self.getName(), 'test')
        if not os.path.exists(testDir):
            os.makedirs(testDir)
        # check if file exists
        fileDir = os.path.join(testDir, filename)
        if os.path.exists(fileDir) and not isOverWrite:
            raise Exception(f'File {fileDir} already exists')
        # create file
        with open(fileDir, 'w') as f:
            f.write(content)
            
    def get_test_content(self, filename) -> str:
        # use getFileContent to get the content of the test file
        testDir = os.path.join(projectDir, self.getName(), 'test')
        fileDir = os.path.join(testDir, filename)
        if not os.path.exists(fileDir):
            raise Exception(f'File {fileDir} does not exist')
        return self.getFileContent(fileDir)
    
    # return tuple (result, error)
    def run_test(self, filename) -> tuple:
        fileDir = os.path.join('test', filename)
        try:
            result = self._runFlutterCLI(['test', fileDir])
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error running flutter test: {e}')
        return result
        pass
    
    def validate(self) -> str:
        # run all tests in the test directory
        testDir = os.path.join(projectDir, self.getName(), 'test')
        for file in os.listdir(testDir):
            if file.endswith('.dart'):
                result, err = self.run_test(file)
                if err:
                    return err
                
        return ''
    
    def getListSourceFiles(self) -> list[str]:
            """_summary_

            Returns:
                list[str]: list of source files in the project relative to project directory
            """
            prjDir = os.path.join(projectDir, self.getName())
            libDir = os.path.join(prjDir, 'lib') 
            sourceFiles = []
            
            # find main.dart first
            if os.path.exists(os.path.join(libDir, 'main.dart')):
                sourceFiles.append(os.path.relpath(os.path.join(libDir, 'main.dart'), prjDir))
            
            for root, dirs, files in os.walk(libDir):
                for file in files:
                    if file.endswith('.dart') and os.path.relpath(os.path.join(root, file), prjDir) not in sourceFiles:
                        sourceFiles.append(os.path.relpath(os.path.join(root, file), prjDir))
                        
            return sourceFiles
    
    def __str__(self) -> str:
        return f'Flutter project {self.getName()} created from {self._git_url}'
    
    pass
 \end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{DependencyDiagram}$ class.}, label={lst:3}]
    from ProjectManager import Project
    from .Flutter import FlutterAnalyzeStrategy
    from .AI_Agent import AI_Agent
    
    class DependencyDiagram:
        
        blocks = []
        connections = []
        
        def __init__(self, project: Project) -> None:
            self.project = project
            self._generateDiagram()
            self.ai_agent = AI_Agent()
            self._getPredictions()
        
        def _generateDiagram(self) -> None:
            # Analyze project abstractly to project's framework
            framework = self.project.getFramework()
            functionName = framework + 'AnalyzeStrategy'
            if functionName in globals():
                globals()[functionName](self)
            else:
                raise Exception('Framework not supported')
            
        def _getPredictions(self) -> None:
            for block in self.blocks:
                block.setPrediction(self.ai_agent.generate_BLA_prediction(source_code=block.getContentNoComment(), chat_history=[]))
            
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{Block}$ class.}, label={lst:4}]
    class Block:
    def __init__(self, name: str, content: str, type: str) -> None:
        self.name = name
        self.content = content
        self.type = type

    def getContentNoComment(self) -> str:
        # no split by line
        content = self.content
        res = ''
        i = 0
        isCommentSingleLine = False
        isCommentMultiLine = False
        while i < len(self.content)-1:
            # if \n, reset isCommentSingleLine
            if content[i] == '\n':
                isCommentSingleLine = False
            if content[i] == '/' and content[i+1] == '*':
                isCommentMultiLine = True
            if content[i] == '/' and content[i+1] == '/':
                isCommentSingleLine = True
            if not isCommentSingleLine and not isCommentMultiLine:
                res += content[i]
            if content[i] == '*' and content[i+1] == '/':
                isCommentMultiLine = False
                i+=1
            i+=1
        
        # delete all empty lines
        res = '\n'.join([line for line in res.split('\n') if line.strip() != ''])
        
        return res
    
    def setPrediction(self, prediction: str) -> None:
        self.prediction = prediction

    def getPrediction(self) -> str:
        return self.prediction
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{BlockType}$ class (Enumerate).}, label={lst:5}]
    class BlockType:
        FILE = 'File'
        CLASS = 'Class'
        ABSTRACT_CLASS = 'AbstractClass'
        ENUM = 'Enum'
        GLOBAL_VAR = 'GlobalVar'
        FUNCTION = 'Function'
        CLASS_CONSTRUCTOR = 'ClassConstructor'
        CLASS_FUNCTION = 'ClassFunction'
        CLASS_ATTRIBUTE = 'ClassAttribute'
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{Connection}$ class.}, label={lst:6}]
    class Connection:
    def __init__(self, head: Block, tail: Block, type: str):
        self.head = head
        self.tail = tail
        self.type = type
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{ConnectionType}$ class (Enumerate).}, label={lst:7}]
    class ConnectionType:
        EXTEND = 'Extend'
        IMPLEMENT = 'Implement'
        CONTAIN = 'Contain'
        EXTEND = 'Extend'
        USE = 'Use'
        CALL = 'Call'
        IMPORT = 'Import'
\end{lstlisting}
 
\begin{lstlisting}[language=Python, caption={$\texttt{FlutterAnalyzeStrategy}$ function.}, label={lst:8}]
    def FlutterAnalyzeStrategy(diagram) -> None:
    # print('Flutter analyze strategy')
    # print(diagram)
    fileList = diagram.project.getListSourceFiles()
    # print(fileList)
    # create a block for main first
    mainfileDir = fileList[0]
    mainFileContent = diagram.project.getFileContent(mainfileDir)
    # turn \ into /
    mainfileDir = mainfileDir.replace('\\','/')
    # print(mainfileDir)
    mainBlock = Block(mainfileDir, mainFileContent, BlockType.FILE)
    # print(mainBlock)
    
    diagram.blocks.append(mainBlock)
    
    ImportAnalyzer(diagram, diagram.blocks[0])
    
    ContainAnalyzer(diagram, diagram.blocks[0])
    
    CallAnalyzer(diagram, diagram.blocks[0])
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{ImportAnalyzer}$ function.}, label={lst:9}]
def ImportAnalyzer(diagram, block):
    currContent = block.content
    currType = block.type
    # print("Current content: ", currentContent)
    # print("Current type: ", currentType)
    
    # analyze imports
    if (currType == 'File'):
        importLines = [line.strip() for line in currContent.split('\n') if line.strip().startswith('import')]
        # print(importLines)
        blocks = []
        for line in importLines:
            # print(line)
            directory = line.split(' ')[1].replace(';', '')
            # delete first and last character => delete quotes
            directory = directory[1:-1]
            # print(directory)
            # 3 cases: import from other package, import from project, import as relative path
            if directory.startswith('package:'):
                # import from other package, import from project
                prjName = diagram.project.yaml_name
                if directory.startswith(f'package:{prjName}'):
                    # import from project
                    # create block for this file and connection
                    fileDir = directory.split(f'package:{prjName}')[1]
                    fileDir = 'lib' + fileDir
                    fileContent = diagram.project.getFileContent(fileDir)
                    # if fileDir is not in Diagram.blocks
                    if not any(block.name == fileDir for block in diagram.blocks):
                        blocks.append(Block(fileDir, fileContent, BlockType.FILE))
                    else: diagram.connections.append(Connection(block, [b for b in diagram.blocks if b.name == fileDir][0], ConnectionType.IMPORT))
            else:
                # import as relative path
                currentDir = block.name #ex: lib/main.dart
                currentDir = currentDir.split('/')
                currentDir.pop()
                currentDir = '/'.join(currentDir)
                combineDir = os.path.normpath(os.path.join(currentDir, directory))
                # print(combineDir)
                fileContent = diagram.project.getFileContent(combineDir)
                if combineDir not in [block.name for block in diagram.blocks]:
                    # turn \ into /
                    combineDir = combineDir.replace('\\','/')
                    blocks.append(Block(combineDir, fileContent, BlockType.FILE))
                else: diagram.connections.append(Connection(block, [b for b in diagram.blocks if b.name == combineDir][0], ConnectionType.IMPORT))
        
        for b in blocks:
            # print(b)
            diagram.blocks.append(b)
            diagram.connections.append(Connection(block, b, ConnectionType.IMPORT))
            ImportAnalyzer(diagram, b)
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{ContainAnalyzer}$ function.}, label={lst:10}]
def ContainAnalyzer(diagram, block, visited = []):
    visited.append(block)
    currType = block.type
    
    # print("Current content: ", currContent)
    # print("Current type: ", currType)
    
    # keep analyze if type is file or class or abstract class
    if (currType == BlockType.FILE 
        or currType == BlockType.CLASS
        or currType == BlockType.ABSTRACT_CLASS
        ):
        content = block.getContentNoComment()
        # print(content)
        lines = content.split('\n')
        # if type is file, analyze classes and functions (standalone functions)
        # if type is class, analyze functions
        blocks = []
        # File analyzing
        if (currType == BlockType.FILE):
            # two cases: class and abstract class
            if 'class ' in content:
                # this file have class(es)
                isClassContent = False
                openedBracket = 0
                className = ''
                classContent = []
                # class or final class
                for line in lines:
                    if line.strip().startswith('class ') or line.strip().startswith('final class '):
                        # first line of class
                        # NOTE: there is no class inside class
                        # get class name
                        className = line.split('class ')[1].split('{')[0].strip()
                        # print(className)
                        isClassContent = True
                        classContent.append(line)
                    elif '}' in line and isClassContent:
                        # two cases: class end or function end
                        classContent.append(line)
                        if '{' in line:
                            continue
                        if openedBracket > 0:
                            openedBracket = openedBracket - 1
                        else: 
                            # class end
                            isClassContent = False
                            classContent = '\n'.join(classContent)
                            blocks.append(Block(className, classContent, BlockType.CLASS))
                            classContent = []
                    elif '{' in line and isClassContent:
                        openedBracket = openedBracket + 1
                        classContent.append(line)
                    elif isClassContent:
                        classContent.append(line)
                
                # abstract class
                if 'abstract class ' in content or 'abstract final class ' in content:
                    isAbstractClassContent = False
                    openedBracket = 0
                    className = ''
                    classContent = []
                    for line in lines:
                        if line.strip().startswith('abstract class ') or line.strip().startswith('abstract final class '):
                            # first line of class
                            # NOTE: there is no class inside class
                            # get class name
                            if line.strip().startswith('abstract class '):
                                
                                className = line.split('abstract class ')[1].split('{')[0].strip()
                            # Check if it's an abstract final class
                            if line.strip().startswith('abstract final class '):
                                className = line.split('abstract final class ')[1].split('{')[0].strip()
                            # print(className)
                            isAbstractClassContent = True
                            classContent.append(line)
                        elif '}' in line and isAbstractClassContent:
                            # two cases: class end or function end
                            classContent.append(line)
                            if '{' in line:
                                continue
                            if openedBracket > 0:
                                openedBracket = openedBracket - 1
                            else: 
                                # class end
                                isAbstractClassContent = False
                                classContent = '\n'.join(classContent)
                                blocks.append(Block(className, classContent, BlockType.ABSTRACT_CLASS))
                                classContent = []
                        elif '{' in line and isAbstractClassContent:
                            openedBracket = openedBracket + 1
                            classContent.append(line)
                        elif isAbstractClassContent:
                            classContent.append(line)
                            
            # enum
            if 'enum ' in content:
                # no {} in enum
                # maybe () in enum
                # once } is found, enum end
                isEnumContent = False
                enumName = ''
                enumContent = []
                for line in lines:
                    if line.strip().startswith('enum '):
                        # first line of enum
                        enumName = line.split('enum ')[1].split('{')[0].strip()
                        isEnumContent = True
                        enumContent.append(line)
                    elif '}' in line and isEnumContent:
                        enumContent.append(line)
                        isEnumContent = False
                        enumContent = '\n'.join(enumContent)
                        blocks.append(Block(enumName, enumContent, BlockType.ENUM))
                        # print(enumContent)
                    elif isEnumContent:
                        enumContent.append(line)
                
            # function
            # standalone function / GlobalVar only!
            # strat: get rid of all analyzed class and enum first
            leftoverContent = content
            for b in blocks:
                leftoverContent = leftoverContent.replace(b.content, '')
            # get rid of import line
            leftoverContent = '\n'.join([line for line in leftoverContent.split('\n') if not line.strip().startswith('import')])
            # remove empty lines
            leftoverContent = '\n'.join([line for line in leftoverContent.split('\n') if line.strip() != ''])
            # print("========Leftover content========")
            # print(block.name)
            # print(leftoverContent)
            
            # two case of function: difined return type or not (dynamic)
            # variable must have a type
            # print("========Function and GlobalVar========")
            funcAndVarBlocks = extract_functions_and_globals(leftoverContent)
            blocks.extend(funcAndVarBlocks)
        
        # Class analyzing
        if (currType in (BlockType.CLASS)):
            # two cases: class function and class attribute
            content = block.getContentNoComment() # should be no difference between content and contentNoComment
            # print(content)
            classContentBlock = extract_class_content(content)
            blocks.extend(classContentBlock)
            
        # blocks recursive
        for b in blocks:
            # print(b)
            # print(b.content)
            diagram.blocks.append(b)
            diagram.connections.append(Connection(block, b, ConnectionType.CONTAIN))
            ContainAnalyzer(diagram, b, visited=visited)
            
    # find connection connected to this block and not visited
    connectedBlocks = [c.tail for c in diagram.connections if c.head == block and c.tail not in visited]
    for b in connectedBlocks:
        ContainAnalyzer(diagram, b, visited=visited)    
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{CallAnalyzer}$ function.}, label={lst:11}]
    def CallAnalyzer(diagram, block, visited = []):
    if block in visited:
        return
    
    visited.append(block)
    currType = block.type
    
    # NOTE strat: 2-layer recursive
    if currType in (BlockType.FILE):
        # find connected file (imported file)
        connectedFiles = [conn.tail for conn in diagram.connections if conn.head == block and conn.type == ConnectionType.IMPORT]
        
        for file in connectedFiles:
            # print("Imported file:")
            # print(file)
            # find all class/function/variable in file. Avoid BlockType.FILE
            connectedBlocks = [conn.tail for conn in diagram.connections if conn.head == file and conn.type == ConnectionType.CONTAIN]
            currentBlocks = [conn.tail for conn in diagram.connections if conn.head == block and conn.type == ConnectionType.CONTAIN]

        
            _CallAnalyzer(diagram, currentBlocks, connectedBlocks, visited)
            # import based recursive call
            CallAnalyzer(diagram, file, visited)
        
def _CallAnalyzer(diagram, thisFile, callables, visited=[]):
    # thisFile: blocks of contains in current file
    # callables: blocks of contains in imported file
    callables.extend(thisFile)
    
    # printStuff(thisFile, callables)
    
    for block in thisFile:
        if block in visited:
            continue
        
        if block.type in (BlockType.ABSTRACT_CLASS, BlockType.CLASS):
            # extend connection analyze
            name = block.name
            # print(name)
            # first word is class name
            classname = name.split()[0]
            otherInfo = name[len(classname):]
            for connBlock in callables:
                if connBlock.type in (BlockType.ABSTRACT_CLASS, BlockType.CLASS):
                    className = connBlock.name.split()[0]
                    # if className found in otherInfo, create a connection ConnectionType.EXTEND
                    if className in otherInfo:
                        diagram.connections.append(Connection(block, connBlock, ConnectionType.EXTEND))
                        # print(f"Extend connection: {block} --> {connBlock}")
                
            # split class, abstract class
            innerBlocks = [conn.tail for conn in diagram.connections if conn.head == block and conn.type == ConnectionType.CONTAIN]
            # magic recursive calls at 4 a.m
            visited.append(block)
            _CallAnalyzer(diagram, innerBlocks, callables, visited)
            
            
            continue
        else:
            visited.append(block)
            # analyze calls in block
            # If called, create a connection ConnectionType.CALL
            
            fullcontent = block.getContentNoComment()
            # print("=====================================")
            # print(block)
            # print(fullcontent)
            
            content = ''
            # Extract content only, exclude function name, params
            if block.type in (BlockType.FUNCTION, BlockType.CLASS_FUNCTION):
                if '=>' in fullcontent:
                    # take content from => to ;
                    # add a ; to the end of content
                    fullcontent = fullcontent + ';'
                    content = fullcontent[fullcontent.index('=>')+2:]
                    content = content[:content.index(';') + 1]
                
                else:
                    roundbracketOpened = 0
                    initialRoundBracket = False
                    curlybracketOpened = 0
                    isContent = False
                    for char in fullcontent:
                        # params section
                        if char == '(' and not isContent and not initialRoundBracket:
                            initialRoundBracket = True
                            roundbracketOpened += 1
                        if char == ')' and not isContent:
                            roundbracketOpened -= 1
                            if roundbracketOpened == 0 and initialRoundBracket:
                                initialRoundBracket = False
                        if char == '{':
                            if not isContent and not initialRoundBracket:
                                isContent = True
                            curlybracketOpened += 1
                        if char == '}' and isContent:
                            curlybracketOpened -= 1
                            if curlybracketOpened == 0:
                                isContent = False
                                content += char
                                break
                        if isContent:
                            content += char
            if block.type in (BlockType.CLASS_ATTRIBUTE):
                # extract content from = to ;
                # add a ; to the end of content
                fullcontent = fullcontent + ';'
                content = fullcontent[fullcontent.index('=')+1:]
                content = content[:content.index(';') + 1]
            # print("====================Block=====================")
            # print("Block name: ", block.name)
            # print("====================Extracted content=====================")
            # print(content)
            # print("==========================================================")
            # printStuff(thisFile, callables)
            callablesName = getCallablesName(callables)
            for name, connBlock in callablesName:
                # print(f"Name: {name}, Block name: {connBlock.name}")
                # find name in content
                # name found can be next to any non-word character or start of line and end of line
                regex = re.compile(r'(?<![a-zA-Z0-9_])' + re.escape(name) + r'(?![a-zA-Z0-9_])')
                if regex.search(content):
                    # check if connection already exists
                    if not any(conn.head == block and conn.tail == connBlock and conn.type == ConnectionType.CALL for conn in diagram.connections):
                        diagram.connections.append(Connection(block, connBlock, ConnectionType.CALL))
                        # print(f"Call connection: {block} --> {connBlock}")
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{AI\_Agent}$ class.}, label={lst:12}]
class AI_Agent:
    def __init__(self) -> None:
        if load_dotenv(override=True) == False:
            raise Exception("Failed to load .env file")
        base_url = os.getenv('BASE_URL')
        model_name = os.getenv('BLA_LLM_MODEL')
        embed_model = os.getenv('EMBED_MODEL')
        self.model = ChatOpenAI(base_url=base_url, model=model_name, temperature=0)
        self.embeddings = OpenAIEmbeddings(
            base_url=base_url, 
            model=embed_model,
            # critical for LM studio mod
            check_embedding_ctx_length=False
        )
        # load vector store
        self.store_names = {
            # "dart_programming_tutorial": "dart_programming_tutorial.pdf",
            # "DartLangSpecDraft": "DartLangSpecDraft.pdf",
            "flutter_tutorial": "flutter_tutorial.pdf",
        } 
        for store_name, doc_name in self.store_names.items():
            if not self._check_if_vector_store_exists(store_name):
                docs = self._load_document(doc_name)
                chunks = self._split_document(docs)
                self._create_vector_store(chunks, store_name)
                
        dbs = []
        for store_name in self.store_names:
            dbs.append(
                Chroma(persist_directory=os.path.join(db_dir, store_name),
                       embedding_function=self.embeddings)
            )
        self.retrievers = []
        for db in dbs:
            self.retrievers.append(
                db.as_retriever(
                    # search_type="similarity",
                    # search_kwargs={"k": docs_num},
                    # search_type="mmr",
                    # search_kwargs={"k": docs_num, "fetch_k": 20, "lambda_mult": 0.5}
                    search_type="similarity_score_threshold",
                    search_kwargs={
                        'score_threshold': 0.4,
                        'k': 1,
                    }
                )
            )
        self._agent_init()
    def generate_BLA_prediction(
        self, 
        source_code: str, 
        chat_history: list
    ) -> str:
        # First use the agent to analyze the code
        response = self.agent_executor.invoke(
            {
                "input": source_code,
                "chat_history": chat_history,
            }
        )
        
        # Then use a direct call to the LLM to structure the output properly
        structured_prompt = (
            "Based on the following analysis of code, create a structured response with the following sections:\n"
            "1. Brief explanation of what the code does\n"
            "2. Testability assessment\n"
            "3. TESTING SCENARIOS in the exact format shown below:\n\n"
            "TESTING SCENARIOS:\n"
            "1. [Descriptive Test Name]: Verify that [functionality]. Input: [specific input values]. Expected: [specific output/behavior].\n"
            "2. [Descriptive Test Name]: Verify that [functionality]. Input: [specific input values]. Expected: [specific output/behavior].\n"
            "3. [Descriptive Test Name]: Verify that [functionality]. Input: [specific input values]. Expected: [specific output/behavior].\n\n"
            "For test names, use descriptive names that clearly indicate the purpose of the test, such as:\n"
            "- 'ValidPalindromeCheck' instead of 'Scenario Name'\n"
            "- 'EmptyStringHandling' instead of generic names\n"
            "- 'BoundaryConditionTest' for edge cases\n"
            "- 'SpecialCharactersTest' for specific input types\n\n"
            "Include at least 4-5 different test scenarios covering normal cases, edge cases, and special conditions.\n"
            "Analysis to structure: " + response["output"]
        )
        
        structured_response = self.model.invoke(structured_prompt)
        return structured_response.content
            
        
        
    def _agent_init(self) -> None:
        contextualize_q_system_prompt = (
            "Given a chat history, user request and the latest piece of user source code, "
            "which might reference context in the chat history, "
            "formulate a statement that can be used to query the model for useful reference."
            "Do NOT include the user request in the query."
            # "DO NOT add the sentence 'Without more context or specific questions about the code, I can't provide a more detailed explanation' in the answer."
        )
        contextualize_q_prompt = ChatPromptTemplate.from_messages(
            [
                ("system", contextualize_q_system_prompt),
                MessagesPlaceholder("chat_history"),
                ("human", "{input}"),
            ]
        )
        # Create a history-aware retriever
        # This uses the LLM to help reformulate the question based on chat history
        history_aware_retrievers = [] 
        
        for retriever in self.retrievers:
            history_aware_retrievers.append(
                create_history_aware_retriever(
                    self.model, retriever, contextualize_q_prompt
                )
            )
        
        bla_system_prompt = (
            "You are an AI assistant that analyzes Flutter/Dart source code to identify its business logic for test generation.\n"
            "You can provide helpful answers using available tools.\n"
            "For the given code snippet:\n\n"
            "1. FUNCTION ANALYSIS:\n"
            "   - What is the purpose of this function/class?\n"
            "   - What are the inputs (parameters) and their types?\n"
            "   - What is the expected output (return value) and its type?\n"
            "   - What algorithm or logic does it implement?\n\n"
            "2. TESTABILITY ASSESSMENT:\n"
            "   - Can this code be tested? If yes, what type of test is appropriate (unit/widget/integration)?\n"
            "   - Are there any dependencies that might complicate testing?\n\n"
            "3. TESTING SCENARIOS:\n"
            "   ALWAYS include at least 3-5 specific test scenarios using EXACTLY this format:\n\n"
            "   TESTING SCENARIOS:\n"
            "   1. [Scenario Name]: Verify that [functionality]. Input: [specific input values]. Expected: [specific output/behavior].\n"
            "   2. [Scenario Name]: Verify that [functionality]. Input: [specific input values]. Expected: [specific output/behavior].\n"
            "   3. [Scenario Name]: Verify that [functionality]. Input: [specific input values]. Expected: [specific output/behavior].\n\n"
            "Keep your analysis concise but precise. DO NOT include the source code in your answer.\n"
            "The TESTING SCENARIOS section MUST follow the exact format shown above, with specific input values and expected outputs.\n"
            "If the code's purpose is unclear, make your best inference based on the implementation details.\n"
            "{context}"
        )
        
        bla_prompt = ChatPromptTemplate.from_messages(
            [
                ("system", bla_system_prompt),
                MessagesPlaceholder("chat_history"),
                ("human", "{input}"),
            ]
        )
        bla_chain = create_stuff_documents_chain(self.model, bla_prompt)
        
        rag_chains = []
        for retriever in history_aware_retrievers:
            rag_chains.append(create_retrieval_chain(retriever, bla_chain))
            
        react_docstore_prompt = hub.pull("hwchase17/react")
        
        tools = []
        
        store_names = []
        for store_name, doc_name in self.store_names.items():
            store_names.append(store_name)
        
        for i in range(len(store_names)):
            # print(f"{store_names[i]}")
            tools.append(
                Tool(
                    name=f"Get code explaination from {store_names[i]}",
                    func=lambda input, **kwargs: rag_chains[i].invoke(
                        {
                            "input": input, 
                            "chat_history": kwargs.get("chat_history", [])
                        }
                    ),
                    description=f"Retrieve documents from the vector store {store_names[i]}",
                )
            )
        agent = create_react_agent(
            llm=self.model,
            tools=tools,
            prompt=react_docstore_prompt,
        )
        
        self.agent_executor = AgentExecutor.from_agent_and_tools(
            agent=agent, 
            tools=tools, 
            handle_parsing_errors=True, 
            verbose=True,
        )
        pass
    # Function to create and persist vector store
    def _create_vector_store(self, docs, store_name, is_overwrite=False) -> None:
        persistent_directory = os.path.join(db_dir, store_name)
        # delete the directory if it exists and needed
        if is_overwrite and os.path.exists(persistent_directory):
            shutil.rmtree(persistent_directory) # remove the directory
            
        if not os.path.exists(persistent_directory):
            print(f"\n--- Creating vector store {store_name} ---")
            db = Chroma.from_documents(
                docs, self.embeddings, persist_directory=persistent_directory
            )
            print(f"--- Finished creating vector store {store_name} ---")
        else:
            print(
                f"Vector store {store_name} already exists. No need to initialize.")
    def _load_document(self, doc_name):
        file_path = os.path.join(docs_dir, doc_name)
        if not os.path.exists(file_path):
            raise FileNotFoundError(
                f"_load_document: The file {file_path} does not exist. Please check the path."
            )
        file_extension = os.path.splitext(file_path)[1]
        # check if the file extension is supported
        if file_extension not in file_loader_map:
            raise Exception(f"_load_document: Unsupported file extension: {file_extension} for file: {file_path}")
        loader = PyPDFLoader(file_path=file_path)
        return loader.load()
    
    def _split_document(self, documents, chunk_size=1000, chunk_overlap=100):
        text_splitter = SentenceTransformersTokenTextSplitter(
            chunk_size=chunk_size, chunk_overlap=chunk_overlap
        )
        return text_splitter.split_documents(documents)
    
    def _check_if_vector_store_exists(self, store_name) -> bool:
        persistent_directory = os.path.join(db_dir, store_name)
        return os.path.exists(persistent_directory)

\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{Sample .env}$ file.}, label={lst:13}]
    OPENAI_API_KEY=sk-this-key-is-just-a-placeholder
    LANGCHAIN_API_KEY=sk-this-key-is-just-a-placeholder
    LANGCHAIN_PROJECT=TestGenie
    
    BASE_URL=
    BLA_LLM_MODEL=
    TG_LLM_MODEL=
    
    EMBED_MODEL=
\end{lstlisting}