\begin{lstlisting}[language=Python, caption={$\texttt{Project}$ class.}, label={lst:1}]
  import os
  import subprocess
  
  class Project:

      _framework = ''
      def __init__(self, git_url):
          self._git_url = git_url
          self._name = git_url.split('/')[-1]
          # print('Project name: ', self._name)
          if self._name.endswith('.git'):
              self._name = self._name[:-4]
          
          # check if project already cloned
          if os.path.exists(projectDir + '/' + self._name):
              return
          else:
              self._clone(git_url)
      
      def _clone(self, git_url):
          # clone the git repository to the project directory
          try:
              # if Project folder not exist, create it
              if not os.path.exists(projectDir):
                  os.makedirs(projectDir)
              return subprocess.check_output(['git', 'clone', git_url, projectDir + '/' + self._name], universal_newlines=True)
          except subprocess.CalledProcessError as e:
              raise Exception(f'Error cloning project: {e}')
      
      def recognizeProjectFramework(self) -> str:
          # TODO: Implement project framework recognition
          return 'flutter'
          pass
      
      def _setFramework(self, framework) -> None:
          self._framework = framework
          
      def getFramework(self) -> str:
          return self._framework
      
      def getName(self) -> str:
          return self._name
      
      def getPath(self) -> str:
          return projectDir + '/' + self._name
          
      def getFileContent(self, fileDir: str) -> str:
          """_summary_
  
          Args:
              fileDir (str): file directory relative to project directory
  
          Returns:
              str: file content
          """
          with open(os.path.join(projectDir, self.getName(), fileDir), 'r') as f:
              return f.read()
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{Flutter}$ class - subclass of Project.}, label={lst:2}]
from ProjectManager import Project, projectDir, os, subprocess, sdkDir

sdkDir = os.path.join(sdkDir, 'flutter')

class Flutter(Project): # Inherit from Project class
    
    def __init__(self, git_url):
        super().__init__(git_url)
        self._setFramework('Flutter')
        self._checkSDK()
        self._flutterPubGet()
        self._addTestDependency()
        self.yaml_name = self._getYamlName()
        # self._createSampleProject('sample')
        
    def _runFlutterCLI(self, args, isRaiseException=False) -> tuple:
        prjDir = os.path.join(projectDir, self.getName())
        flutterBatDir = os.path.join(sdkDir, 'bin', 'flutter')

        cmd = [flutterBatDir]
        # args handling
        # if args is a string that have space, convert it to list
        if isinstance(args, str) and ' ' in args:
            args = args.split()
        if isinstance(args, list):
            cmd.extend(args)
            
        # run cmd via subprocess
        try:
            process = subprocess.Popen(cmd, cwd=prjDir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, encoding='utf-8', shell=True)
            stdout, stderr = process.communicate()
            if process.returncode != 0 and isRaiseException:
                raise Exception(f'Error running flutter command: {stderr}')
            return stdout, stderr
        except subprocess.CalledProcessError as e:
            if isRaiseException:
                raise Exception(f'Error running flutter command: {e}')
            return e.__dict__, e.args
    
    def _checkSDK(self) -> None:
        # Check if flutter sdk is installed
        if not os.path.exists(sdkDir):
            print('Flutter SDK not found')
            return
        # run sdk from sdkDir
        try:
            self._runFlutterCLI('--version', isRaiseException=True)
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error checking flutter sdk: {e}')
        
        # print(result)
    
    def _getYamlName(self) -> str:

        yamlContent = self.getFileContent('pubspec.yaml')
        # print(yamlContent)
        # first line should define the name of the project: "name: ....."
        return yamlContent.split('\n')[0].split('name: ')[1].strip()

    
    # function for testing only. Do not use in production
    def _createSampleProject(self, prjName) -> str:
        try:
            # cannot use _runFlutterCLI because no project directory yet
            # result = self._runFlutterCLI(['create', prjName], isRaiseException=True)
            result = subprocess.check_output([os.path.join(sdkDir, 'bin', 'flutter'), 'create', prjName],cwd=projectDir, universal_newlines=True, encoding='utf-8',  shell=True)
            
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error creating flutter project: {e}')
        return result
    
    def _flutterPubGet(self) -> None:
        # prjDir = os.path.join(projectDir, self.getName())
        # flutterBatDir = os.path.join(sdkDir, 'bin', 'flutter.bat')
        
        try:
            # result = subprocess.check_output([flutterBatDir, 'pub', 'get'], cwd=prjDir, universal_newlines=True)
            self._runFlutterCLI(['pub', 'get', '--no-example'], isRaiseException=True)
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error running flutter pub get: {e}')
        
        # print(result)
        
    def _addTestDependency(self) -> None:
        # run pub add test
        try:
            self._runFlutterCLI(['pub', 'add', 'test'], isRaiseException=True)
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error adding test dependency: {e}')
        # print(result)
    
    def create_test(self, filename, content, isOverWrite = False) -> None:
        # create test file in the test directory
        # check if test directory exists
        testDir = os.path.join(projectDir, self.getName(), 'test')
        if not os.path.exists(testDir):
            os.makedirs(testDir)
        # check if file exists
        fileDir = os.path.join(testDir, filename)
        if os.path.exists(fileDir) and not isOverWrite:
            raise Exception(f'File {fileDir} already exists')
        # create file
        with open(fileDir, 'w') as f:
            f.write(content)
            
    def get_test_content(self, filename) -> str:
        # use getFileContent to get the content of the test file
        testDir = os.path.join(projectDir, self.getName(), 'test')
        fileDir = os.path.join(testDir, filename)
        if not os.path.exists(fileDir):
            raise Exception(f'File {fileDir} does not exist')
        return self.getFileContent(fileDir)
    
    # return tuple (result, error)
    def run_test(self, filename) -> tuple:
        fileDir = os.path.join('test', filename)
        try:
            result = self._runFlutterCLI(['test', fileDir])
        except subprocess.CalledProcessError as e:
            raise Exception(f'Error running flutter test: {e}')
        return result
        pass
    
    def validate(self) -> str:
        # run all tests in the test directory
        testDir = os.path.join(projectDir, self.getName(), 'test')
        for file in os.listdir(testDir):
            if file.endswith('.dart'):
                result, err = self.run_test(file)
                if err:
                    return err
                
        return ''
    
    def getListSourceFiles(self) -> list[str]:
            """_summary_

            Returns:
                list[str]: list of source files in the project relative to project directory
            """
            prjDir = os.path.join(projectDir, self.getName())
            libDir = os.path.join(prjDir, 'lib') 
            sourceFiles = []
            
            # find main.dart first
            if os.path.exists(os.path.join(libDir, 'main.dart')):
                sourceFiles.append(os.path.relpath(os.path.join(libDir, 'main.dart'), prjDir))
            
            for root, dirs, files in os.walk(libDir):
                for file in files:
                    if file.endswith('.dart') and os.path.relpath(os.path.join(root, file), prjDir) not in sourceFiles:
                        sourceFiles.append(os.path.relpath(os.path.join(root, file), prjDir))
                        
            return sourceFiles
    
    def __str__(self) -> str:
        return f'Flutter project {self.getName()} created from {self._git_url}'
    
    pass
 \end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{DependencyDiagram}$ class.}, label={lst:3}]
    from ProjectManager import Project
    from .Flutter import FlutterAnalyzeStrategy
    from .AI_Agent import AI_Agent
    
    class DependencyDiagram:
        
        blocks = []
        connections = []
        
        def __init__(self, project: Project) -> None:
            self.project = project
            self._generateDiagram()
            self.ai_agent = AI_Agent()
            self._getPredictions()
        
        def _generateDiagram(self) -> None:
            # Analyze project abstractly to project's framework
            framework = self.project.getFramework()
            functionName = framework + 'AnalyzeStrategy'
            if functionName in globals():
                globals()[functionName](self)
            else:
                raise Exception('Framework not supported')
            
        def _getPredictions(self) -> None:
            for block in self.blocks:
                block.setPrediction(self.ai_agent.generate_BLA_prediction(source_code=block.getContentNoComment(), chat_history=[]))
            
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{Block}$ class.}, label={lst:4}]
    class Block:
    def __init__(self, name: str, content: str, type: str) -> None:
        self.name = name
        self.content = content
        self.type = type

    def getContentNoComment(self) -> str:
        # no split by line
        content = self.content
        res = ''
        i = 0
        isCommentSingleLine = False
        isCommentMultiLine = False
        while i < len(self.content)-1:
            # if \n, reset isCommentSingleLine
            if content[i] == '\n':
                isCommentSingleLine = False
            if content[i] == '/' and content[i+1] == '*':
                isCommentMultiLine = True
            if content[i] == '/' and content[i+1] == '/':
                isCommentSingleLine = True
            if not isCommentSingleLine and not isCommentMultiLine:
                res += content[i]
            if content[i] == '*' and content[i+1] == '/':
                isCommentMultiLine = False
                i+=1
            i+=1
        
        # delete all empty lines
        res = '\n'.join([line for line in res.split('\n') if line.strip() != ''])
        
        return res
    
    def setPrediction(self, prediction: str) -> None:
        self.prediction = prediction

    def getPrediction(self) -> str:
        return self.prediction
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{BlockType}$ class (Enumerate).}, label={lst:5}]
    class BlockType:
        FILE = 'File'
        CLASS = 'Class'
        ABSTRACT_CLASS = 'AbstractClass'
        ENUM = 'Enum'
        GLOBAL_VAR = 'GlobalVar'
        FUNCTION = 'Function'
        CLASS_CONSTRUCTOR = 'ClassConstructor'
        CLASS_FUNCTION = 'ClassFunction'
        CLASS_ATTRIBUTE = 'ClassAttribute'
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{Connection}$ class.}, label={lst:6}]
    class Connection:
    def __init__(self, head: Block, tail: Block, type: str):
        self.head = head
        self.tail = tail
        self.type = type
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{ConnectionType}$ class (Enumerate).}, label={lst:7}]
    class ConnectionType:
        EXTEND = 'Extend'
        IMPLEMENT = 'Implement'
        CONTAIN = 'Contain'
        EXTEND = 'Extend'
        USE = 'Use'
        CALL = 'Call'
        IMPORT = 'Import'
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{FlutterAnalyzeStrategy}$ function.}, label={lst:8}]
    def FlutterAnalyzeStrategy(diagram) -> None:
    # print('Flutter analyze strategy')
    # print(diagram)
    fileList = diagram.project.getListSourceFiles()
    # print(fileList)
    # create a block for main first
    mainfileDir = fileList[0]
    mainFileContent = diagram.project.getFileContent(mainfileDir)
    # turn \ into /
    mainfileDir = mainfileDir.replace('\\','/')
    # print(mainfileDir)
    mainBlock = Block(mainfileDir, mainFileContent, BlockType.FILE)
    # print(mainBlock)
    
    diagram.blocks.append(mainBlock)
    
    ImportAnalyzer(diagram, diagram.blocks[0])
    
    ContainAnalyzer(diagram, diagram.blocks[0])
    
    CallAnalyzer(diagram, diagram.blocks[0])
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{ImportAnalyzer}$ function.}, label={lst:9}]
def ImportAnalyzer(diagram, block):
    currContent = block.content
    currType = block.type
    # print("Current content: ", currentContent)
    # print("Current type: ", currentType)
    
    # analyze imports
    if (currType == 'File'):
        importLines = [line.strip() for line in currContent.split('\n') if line.strip().startswith('import')]
        # print(importLines)
        blocks = []
        for line in importLines:
            # print(line)
            directory = line.split(' ')[1].replace(';', '')
            # delete first and last character => delete quotes
            directory = directory[1:-1]
            # print(directory)
            # 3 cases: import from other package, import from project, import as relative path
            if directory.startswith('package:'):
                # import from other package, import from project
                prjName = diagram.project.yaml_name
                if directory.startswith(f'package:{prjName}'):
                    # import from project
                    # create block for this file and connection
                    fileDir = directory.split(f'package:{prjName}')[1]
                    fileDir = 'lib' + fileDir
                    fileContent = diagram.project.getFileContent(fileDir)
                    # if fileDir is not in Diagram.blocks
                    if not any(block.name == fileDir for block in diagram.blocks):
                        blocks.append(Block(fileDir, fileContent, BlockType.FILE))
                    else: diagram.connections.append(Connection(block, [b for b in diagram.blocks if b.name == fileDir][0], ConnectionType.IMPORT))
            else:
                # import as relative path
                currentDir = block.name #ex: lib/main.dart
                currentDir = currentDir.split('/')
                currentDir.pop()
                currentDir = '/'.join(currentDir)
                combineDir = os.path.normpath(os.path.join(currentDir, directory))
                # print(combineDir)
                fileContent = diagram.project.getFileContent(combineDir)
                if combineDir not in [block.name for block in diagram.blocks]:
                    # turn \ into /
                    combineDir = combineDir.replace('\\','/')
                    blocks.append(Block(combineDir, fileContent, BlockType.FILE))
                else: diagram.connections.append(Connection(block, [b for b in diagram.blocks if b.name == combineDir][0], ConnectionType.IMPORT))
        
        for b in blocks:
            # print(b)
            diagram.blocks.append(b)
            diagram.connections.append(Connection(block, b, ConnectionType.IMPORT))
            ImportAnalyzer(diagram, b)
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{ContainAnalyzer}$ function.}, label={lst:10}]
def ContainAnalyzer(diagram, block, visited = []):
    visited.append(block)
    currType = block.type
    
    # print("Current content: ", currContent)
    # print("Current type: ", currType)
    
    # keep analyze if type is file or class or abstract class
    if (currType == BlockType.FILE 
        or currType == BlockType.CLASS
        or currType == BlockType.ABSTRACT_CLASS
        ):
        content = block.getContentNoComment()
        # print(content)
        lines = content.split('\n')
        # if type is file, analyze classes and functions (standalone functions)
        # if type is class, analyze functions
        blocks = []
        # File analyzing
        if (currType == BlockType.FILE):
            # two cases: class and abstract class
            if 'class ' in content:
                # this file have class(es)
                isClassContent = False
                openedBracket = 0
                className = ''
                classContent = []
                # class or final class
                for line in lines:
                    if line.strip().startswith('class ') or line.strip().startswith('final class '):
                        # first line of class
                        # NOTE: there is no class inside class
                        # get class name
                        className = line.split('class ')[1].split('{')[0].strip()
                        # print(className)
                        isClassContent = True
                        classContent.append(line)
                    elif '}' in line and isClassContent:
                        # two cases: class end or function end
                        classContent.append(line)
                        if '{' in line:
                            continue
                        if openedBracket > 0:
                            openedBracket = openedBracket - 1
                        else: 
                            # class end
                            isClassContent = False
                            classContent = '\n'.join(classContent)
                            blocks.append(Block(className, classContent, BlockType.CLASS))
                            classContent = []
                    elif '{' in line and isClassContent:
                        openedBracket = openedBracket + 1
                        classContent.append(line)
                    elif isClassContent:
                        classContent.append(line)
                
                # abstract class
                if 'abstract class ' in content or 'abstract final class ' in content:
                    isAbstractClassContent = False
                    openedBracket = 0
                    className = ''
                    classContent = []
                    for line in lines:
                        if line.strip().startswith('abstract class ') or line.strip().startswith('abstract final class '):
                            # first line of class
                            # NOTE: there is no class inside class
                            # get class name
                            if line.strip().startswith('abstract class '):
                                
                                className = line.split('abstract class ')[1].split('{')[0].strip()
                            # Check if it's an abstract final class
                            if line.strip().startswith('abstract final class '):
                                className = line.split('abstract final class ')[1].split('{')[0].strip()
                            # print(className)
                            isAbstractClassContent = True
                            classContent.append(line)
                        elif '}' in line and isAbstractClassContent:
                            # two cases: class end or function end
                            classContent.append(line)
                            if '{' in line:
                                continue
                            if openedBracket > 0:
                                openedBracket = openedBracket - 1
                            else: 
                                # class end
                                isAbstractClassContent = False
                                classContent = '\n'.join(classContent)
                                blocks.append(Block(className, classContent, BlockType.ABSTRACT_CLASS))
                                classContent = []
                        elif '{' in line and isAbstractClassContent:
                            openedBracket = openedBracket + 1
                            classContent.append(line)
                        elif isAbstractClassContent:
                            classContent.append(line)
                            
            # enum
            if 'enum ' in content:
                # no {} in enum
                # maybe () in enum
                # once } is found, enum end
                isEnumContent = False
                enumName = ''
                enumContent = []
                for line in lines:
                    if line.strip().startswith('enum '):
                        # first line of enum
                        enumName = line.split('enum ')[1].split('{')[0].strip()
                        isEnumContent = True
                        enumContent.append(line)
                    elif '}' in line and isEnumContent:
                        enumContent.append(line)
                        isEnumContent = False
                        enumContent = '\n'.join(enumContent)
                        blocks.append(Block(enumName, enumContent, BlockType.ENUM))
                        # print(enumContent)
                    elif isEnumContent:
                        enumContent.append(line)
                
            # function
            # standalone function / GlobalVar only!
            # strat: get rid of all analyzed class and enum first
            leftoverContent = content
            for b in blocks:
                leftoverContent = leftoverContent.replace(b.content, '')
            # get rid of import line
            leftoverContent = '\n'.join([line for line in leftoverContent.split('\n') if not line.strip().startswith('import')])
            # remove empty lines
            leftoverContent = '\n'.join([line for line in leftoverContent.split('\n') if line.strip() != ''])
            # print("========Leftover content========")
            # print(block.name)
            # print(leftoverContent)
            
            # two case of function: difined return type or not (dynamic)
            # variable must have a type
            # print("========Function and GlobalVar========")
            funcAndVarBlocks = extract_functions_and_globals(leftoverContent)
            blocks.extend(funcAndVarBlocks)
        
        # Class analyzing
        if (currType in (BlockType.CLASS)):
            # two cases: class function and class attribute
            content = block.getContentNoComment() # should be no difference between content and contentNoComment
            # print(content)
            classContentBlock = extract_class_content(content)
            blocks.extend(classContentBlock)
            
        # blocks recursive
        for b in blocks:
            # print(b)
            # print(b.content)
            diagram.blocks.append(b)
            diagram.connections.append(Connection(block, b, ConnectionType.CONTAIN))
            ContainAnalyzer(diagram, b, visited=visited)
            
    # find connection connected to this block and not visited
    connectedBlocks = [c.tail for c in diagram.connections if c.head == block and c.tail not in visited]
    for b in connectedBlocks:
        ContainAnalyzer(diagram, b, visited=visited)    
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={$\texttt{CallAnalyzer}$ function.}, label={lst:11}]
    def CallAnalyzer(diagram, block, visited = []):
    if block in visited:
        return
    
    visited.append(block)
    currType = block.type
    
    # NOTE strat: 2-layer recursive
    if currType in (BlockType.FILE):
        # find connected file (imported file)
        connectedFiles = [conn.tail for conn in diagram.connections if conn.head == block and conn.type == ConnectionType.IMPORT]
        
        for file in connectedFiles:
            # print("Imported file:")
            # print(file)
            # find all class/function/variable in file. Avoid BlockType.FILE
            connectedBlocks = [conn.tail for conn in diagram.connections if conn.head == file and conn.type == ConnectionType.CONTAIN]
            currentBlocks = [conn.tail for conn in diagram.connections if conn.head == block and conn.type == ConnectionType.CONTAIN]

        
            _CallAnalyzer(diagram, currentBlocks, connectedBlocks, visited)
            # import based recursive call
            CallAnalyzer(diagram, file, visited)
        
def _CallAnalyzer(diagram, thisFile, callables, visited=[]):
    # thisFile: blocks of contains in current file
    # callables: blocks of contains in imported file
    callables.extend(thisFile)
    
    # printStuff(thisFile, callables)
    
    for block in thisFile:
        if block in visited:
            continue
        
        if block.type in (BlockType.ABSTRACT_CLASS, BlockType.CLASS):
            # extend connection analyze
            name = block.name
            # print(name)
            # first word is class name
            classname = name.split()[0]
            otherInfo = name[len(classname):]
            for connBlock in callables:
                if connBlock.type in (BlockType.ABSTRACT_CLASS, BlockType.CLASS):
                    className = connBlock.name.split()[0]
                    # if className found in otherInfo, create a connection ConnectionType.EXTEND
                    if className in otherInfo:
                        diagram.connections.append(Connection(block, connBlock, ConnectionType.EXTEND))
                        # print(f"Extend connection: {block} --> {connBlock}")
                
            # split class, abstract class
            innerBlocks = [conn.tail for conn in diagram.connections if conn.head == block and conn.type == ConnectionType.CONTAIN]
            # magic recursive calls at 4 a.m
            visited.append(block)
            _CallAnalyzer(diagram, innerBlocks, callables, visited)
            
            
            continue
        else:
            visited.append(block)
            # analyze calls in block
            # If called, create a connection ConnectionType.CALL
            
            fullcontent = block.getContentNoComment()
            # print("=====================================")
            # print(block)
            # print(fullcontent)
            
            content = ''
            # Extract content only, exclude function name, params
            if block.type in (BlockType.FUNCTION, BlockType.CLASS_FUNCTION):
                if '=>' in fullcontent:
                    # take content from => to ;
                    # add a ; to the end of content
                    fullcontent = fullcontent + ';'
                    content = fullcontent[fullcontent.index('=>')+2:]
                    content = content[:content.index(';') + 1]
                
                else:
                    roundbracketOpened = 0
                    initialRoundBracket = False
                    curlybracketOpened = 0
                    isContent = False
                    for char in fullcontent:
                        # params section
                        if char == '(' and not isContent and not initialRoundBracket:
                            initialRoundBracket = True
                            roundbracketOpened += 1
                        if char == ')' and not isContent:
                            roundbracketOpened -= 1
                            if roundbracketOpened == 0 and initialRoundBracket:
                                initialRoundBracket = False
                        if char == '{':
                            if not isContent and not initialRoundBracket:
                                isContent = True
                            curlybracketOpened += 1
                        if char == '}' and isContent:
                            curlybracketOpened -= 1
                            if curlybracketOpened == 0:
                                isContent = False
                                content += char
                                break
                        if isContent:
                            content += char
            if block.type in (BlockType.CLASS_ATTRIBUTE):
                # extract content from = to ;
                # add a ; to the end of content
                fullcontent = fullcontent + ';'
                content = fullcontent[fullcontent.index('=')+1:]
                content = content[:content.index(';') + 1]
            # print("====================Block=====================")
            # print("Block name: ", block.name)
            # print("====================Extracted content=====================")
            # print(content)
            # print("==========================================================")
            # printStuff(thisFile, callables)
            callablesName = getCallablesName(callables)
            for name, connBlock in callablesName:
                # print(f"Name: {name}, Block name: {connBlock.name}")
                # find name in content
                # name found can be next to any non-word character or start of line and end of line
                regex = re.compile(r'(?<![a-zA-Z0-9_])' + re.escape(name) + r'(?![a-zA-Z0-9_])')
                if regex.search(content):
                    # check if connection already exists
                    if not any(conn.head == block and conn.tail == connBlock and conn.type == ConnectionType.CALL for conn in diagram.connections):
                        diagram.connections.append(Connection(block, connBlock, ConnectionType.CALL))
                        # print(f"Call connection: {block} --> {connBlock}")
\end{lstlisting}